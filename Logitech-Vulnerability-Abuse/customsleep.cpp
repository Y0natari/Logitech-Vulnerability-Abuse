#include "customsleep.h"
#include "mouse.h"

namespace Global {
    double TimerResolution{ 0.0 }; // Global variable for timer resolution
}

// Timer class constructor, initializes StartTime with current performance counter
CTimer::CTimer() {
    QueryPerformanceCounter(&StartTime);
}

// Updates the StartTime with the current performance counter
void CTimer::Update() {
    QueryPerformanceCounter(&StartTime);
}

// Returns the elapsed time in milliseconds since the last update
double CTimer::Elapsed() {
    LARGE_INTEGER CurrentTime, ElapsedQPC, Frequency;
    QueryPerformanceFrequency(&Frequency);
    QueryPerformanceCounter(&CurrentTime);
    ElapsedQPC.QuadPart = CurrentTime.QuadPart - StartTime.QuadPart;

    double ElapsedTime = ((static_cast<double>(ElapsedQPC.QuadPart) * 1000.0) /
        static_cast<double>(Frequency.QuadPart));

    return ElapsedTime;
}

// Sets the system timer resolution
bool SetTimerResolution() {
#define STATUS_SUCCESS 0x00000000
    constexpr double NanoToMilli{ 0.0001 };
    static NTSTATUS(__stdcall * NtQueryTimerResolution)(OUT PULONG MinimumResolution, OUT PULONG MaximumResolution, OUT PULONG CurrentResolution) =
        (NTSTATUS(__stdcall*)(PULONG, PULONG, PULONG))GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryTimerResolution");
    static NTSTATUS(__stdcall * NtSetTimerResolution)(IN ULONG RequestedResolution, IN BOOLEAN Set, OUT PULONG ActualResolution) =
        (NTSTATUS(__stdcall*)(ULONG, BOOLEAN, PULONG))GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtSetTimerResolution");

    if ((NtQueryTimerResolution == nullptr) || (NtSetTimerResolution == nullptr))
        return false;

    ULONG MinimumResolution{}, MaximumResolution{}, CurrentResolution{};
    if (NtQueryTimerResolution(&MinimumResolution, &MaximumResolution, &CurrentResolution) != STATUS_SUCCESS)
        return false;

    if (NtSetTimerResolution(min(MinimumResolution, MaximumResolution), TRUE, &CurrentResolution) != STATUS_SUCCESS)
        return false;

    Global::TimerResolution = min(MinimumResolution, MaximumResolution) * NanoToMilli;

    return true;
}


static NTSTATUS(__stdcall* NtDelayExecution)(IN BOOLEAN Alertable, IN PLARGE_INTEGER DelayInterval) = (NTSTATUS(__stdcall*)(BOOLEAN, PLARGE_INTEGER))GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtDelayExecution");

// Function to sleep for a specific amount of milliseconds, more accurate than Sleep()
void pQuerySleep(int ms) {
    LONGLONG timerResolution;
    LONGLONG wantedTime;
    LONGLONG currentTime;

    QueryPerformanceFrequency((LARGE_INTEGER*)&timerResolution);
    timerResolution /= 1000;

    QueryPerformanceCounter((LARGE_INTEGER*)&currentTime);
    wantedTime = currentTime / timerResolution + ms;
    currentTime = 0;
    while (currentTime < wantedTime) {
        QueryPerformanceCounter((LARGE_INTEGER*)&currentTime);
        currentTime /= timerResolution;
    }
}

// Accurate sleep function, accounts for excess time
void AccurateSleep(double Delay, CTimer& Excess) {
    CTimer Timer;
    constexpr double MilliToNano{ 5000.0 };
    LARGE_INTEGER DelayInterval{};

    if (Delay > Excess.Elapsed())
        Delay -= Excess.Elapsed();

    DelayInterval.QuadPart = static_cast<LONGLONG>(-Delay * MilliToNano);
    NtDelayExecution(FALSE, &DelayInterval);

    while (Delay >= Timer.Elapsed());
    Excess.Update();
}
