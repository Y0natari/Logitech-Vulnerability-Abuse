#include "mouse.h"

// Constructor for HandleWrapper, just initializes handle_ to nullptr
Mouse::HandleWrapper::HandleWrapper() : handle_(nullptr) {}

// Destructor for HandleWrapper, cleans up by closing the handle if it's valid
Mouse::HandleWrapper::~HandleWrapper() {
    if (handle_) CloseHandle(handle_);
}

// Allows HandleWrapper to be used as HANDLE
Mouse::HandleWrapper::operator HANDLE() const {
    return handle_;
}

// Allows HandleWrapper to return its handle address
HANDLE* Mouse::HandleWrapper::operator&() {
    return &handle_;
}

// Checks if the handle is valid (non-null)
bool Mouse::HandleWrapper::IsValid() const {
    return handle_ != nullptr;
}

// Assigns a new handle, making sure to close any existing one first
Mouse::HandleWrapper& Mouse::HandleWrapper::operator=(HANDLE other) {
    if (handle_) CloseHandle(handle_);
    handle_ = other;
    return *this;
}

// Constructor for Mouse, initializes found_mouse_ to false and io_ to default
Mouse::Mouse() : found_mouse_(false), io_{} {}

// Opens the mouse device by trying a couple of hardcoded device paths
bool Mouse::Open() {
    if (!input_.IsValid()) {
        wchar_t buffer0[] = L"\\??\\ROOT#SYSTEM#0001#{1abc05c0-c378-41b9-9cef-df1aba82b015}";
        NTSTATUS status = DeviceInitialize(buffer0);
        if (NT_SUCCESS(status)) {
            found_mouse_ = true;
        }
        else {
            wchar_t buffer1[] = L"\\??\\ROOT#SYSTEM#0002#{1abc05c0-c378-41b9-9cef-df1aba82b015}";
            status = DeviceInitialize(buffer1);
            if (NT_SUCCESS(status)) {
                found_mouse_ = true;
            }
        }
    }
    return found_mouse_;
}

// Closes the mouse device handle if it's valid
void Mouse::Close() {
    if (input_.IsValid()) {
        CloseHandle(input_);
        input_ = nullptr;
    }
}

// Sends a move command to the mouse, reopens the device if it fails
void Mouse::Move(char button, char x, char y, char wheel) {
    MOUSE_IO io = { button, x, y, wheel, 0 };
    if (!CallMouse(&io)) {
        Close();
        Open();
    }
}

// Calls a control function on the mouse device, returns success status
bool Mouse::CallMouse(MOUSE_IO* buffer) {
    IO_STATUS_BLOCK block;
    return NtDeviceIoControlFile(input_, 0, 0, 0, &block, 0x2a2010, buffer, sizeof(MOUSE_IO), 0, 0) == 0L;
}

// Initializes the device with the provided name
NTSTATUS Mouse::DeviceInitialize(PCWSTR device_name) {
    UNICODE_STRING name;
    OBJECT_ATTRIBUTES attr;

    RtlInitUnicodeString(&name, device_name);
    InitializeObjectAttributes(&attr, &name, 0, nullptr, nullptr);

    return NtCreateFile(&input_, GENERIC_WRITE | SYNCHRONIZE, &attr, &io_, 0,
        FILE_ATTRIBUTE_NORMAL, 0, 3, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, 0, 0);
}
