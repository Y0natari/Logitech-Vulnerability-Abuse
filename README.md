# Logitech-Vulnerability-Abuse

This project demonstrates how to use a virtual Logitech G Hub driver for programmable mouse movements. It's especially handy when you want to avoid using the built-in Lua scripting in G Hub or when you want to use scripts on non-Logitech mice.

## Prerequisites 📋

To ensure the project works correctly, you need to download Logitech G Hub version 2021.3 from the following link:

[Download Logitech G Hub 2021.3](https://www.touslesdrivers.com/index.php?v_page=23&v_code=68333)

**How to download the old version correctly:**
1. Go to the link above
2. Find the floppy disk icon on the page and click on it
3. In the window that pops up, click on the second server to download (**toulesdrivers** server). If you try to download the file from Logitech's servers, you will get the current(the newest) version, which is no longer supported

## Building the Project 🛠️

Follow these steps to build the project:

1. **Clone the Repository**:
    ```bash
    git clone https://github.com/Y0natari/Logitech-Vulnerability-Abuse.git
    cd Logitech-Vulnerability-Abuse
    ```

2. **Set Up Your Environment**:
    - Make sure you have Visual Studio installed with the Desktop development with C++ workload.
    - Open the project in Visual Studio.

3. **Build the Solution**:
    - In Visual Studio, go to `Build` -> `Build Solution` or press `Ctrl+Shift+B`.

## Usage 🚀

After building the project, run the executable. The program will initialize the virtual driver and start listening for mouse movement commands. You can customize the mouse movements by modifying the code in `Logitech-Vulnerability-Abuse.cpp`.

### Example Code Snippet

Here's a quick example of how the mouse movement is programmed:

```cpp
while (true) {
	std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Sleep for 10 milliseconds
	if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) && (GetAsyncKeyState(VK_RBUTTON) & 0x8000)) { //if LBM && RBM are pressed
		mouse.Move(0, 0, 1, 0); // Move the mouse to the relative coordinate (0, 1)
		AccurateSleep(1, Excess); // Accurate sleep for 1 millisecond
	}
}
